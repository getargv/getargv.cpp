<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libgetargv++: Getargv::Iterator&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libgetargv++<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">C++ library for getting and printing other processes&#39; args</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGetargv.html">Getargv</a></li><li class="navelem"><a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structGetargv_1_1Iterator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Getargv::Iterator&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A template that turns a pointer to a C style array into a C++ contiguous iterator.  
 <a href="structGetargv_1_1Iterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iter_8hpp_source.html">iter.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a929ba25515da1946c3f655069420f3ea" id="r_a929ba25515da1946c3f655069420f3ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a929ba25515da1946c3f655069420f3ea">iterator_concept</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/iterator_tags.html">std::contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:a929ba25515da1946c3f655069420f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A marker for the capabilities of this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>. This is the strongest type of iterator in C++ &gt;= 20, and we can satisfy the requirements, so users can use this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> with as many algorithms from <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm.html">std::algorithm</a> as possible.  <br /></td></tr>
<tr class="separator:a929ba25515da1946c3f655069420f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0da64fb40e92a0a012c769183af72e2" id="r_ac0da64fb40e92a0a012c769183af72e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a></td></tr>
<tr class="memdesc:ac0da64fb40e92a0a012c769183af72e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type that represents the distance between two Iterators. The Iterators being compared must point to the same backing buffer, or you get UB.  <br /></td></tr>
<tr class="separator:ac0da64fb40e92a0a012c769183af72e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac726511006292065647099fdffa2ba26" id="r_ac726511006292065647099fdffa2ba26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> = T</td></tr>
<tr class="memdesc:ac726511006292065647099fdffa2ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the elements this iterator provides access to. The type of the iterator's elements/values is provided as a template parameter when this template is instantiated.  <br /></td></tr>
<tr class="separator:ac726511006292065647099fdffa2ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2939378d534b9e2466d8063c382f73fa" id="r_a2939378d534b9e2466d8063c382f73fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a2939378d534b9e2466d8063c382f73fa">value_type</a> = <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a></td></tr>
<tr class="memdesc:a2939378d534b9e2466d8063c382f73fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the values this iterator provides access to. The type of the iterator's elements/values is provided as a template parameter when this template is instantiated.  <br /></td></tr>
<tr class="separator:a2939378d534b9e2466d8063c382f73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03e5013f104eefa151281c29e6d95cd" id="r_ac03e5013f104eefa151281c29e6d95cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ac03e5013f104eefa151281c29e6d95cd">pointer</a> = <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> *</td></tr>
<tr class="memdesc:ac03e5013f104eefa151281c29e6d95cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a pointer to an element this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> provides access to.  <br /></td></tr>
<tr class="separator:ac03e5013f104eefa151281c29e6d95cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7331be6d1d6accadcf214298c762ae7" id="r_ad7331be6d1d6accadcf214298c762ae7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a> = <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> &amp;</td></tr>
<tr class="memdesc:ad7331be6d1d6accadcf214298c762ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a reference to an element this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> provides access to.  <br /></td></tr>
<tr class="separator:ad7331be6d1d6accadcf214298c762ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6408f4d988affa5bb20bea17a46b8fa" id="r_ae6408f4d988affa5bb20bea17a46b8fa"><td class="memItemLeft" align="right" valign="top"><a id="ae6408f4d988affa5bb20bea17a46b8fa" name="ae6408f4d988affa5bb20bea17a46b8fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b> ()=default</td></tr>
<tr class="memdesc:ae6408f4d988affa5bb20bea17a46b8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor. This constructor creates an empty iterator with no backing buffer. The iterator this constructor creates is not usable for anything, but is required to conform to the contiguous_iterator concept. <br /></td></tr>
<tr class="separator:ae6408f4d988affa5bb20bea17a46b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba70972deb99f5f4e5ac59815b8bae5" id="r_a2ba70972deb99f5f4e5ac59815b8bae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a2ba70972deb99f5f4e5ac59815b8bae5">Iterator</a> (<a class="el" href="structGetargv_1_1Iterator.html#ac03e5013f104eefa151281c29e6d95cd">pointer</a> ptr)</td></tr>
<tr class="memdesc:a2ba70972deb99f5f4e5ac59815b8bae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that takes a pointer (C array).  <br /></td></tr>
<tr class="separator:a2ba70972deb99f5f4e5ac59815b8bae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc4d89dde9e9862d0198a374bd67ee8" id="r_aadc4d89dde9e9862d0198a374bd67ee8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#aadc4d89dde9e9862d0198a374bd67ee8">operator*</a> () const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a></td></tr>
<tr class="memdesc:aadc4d89dde9e9862d0198a374bd67ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indirection operator.  <br /></td></tr>
<tr class="separator:aadc4d89dde9e9862d0198a374bd67ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc08e7fd84ac0d93ed54a46e41eb891" id="r_a0dc08e7fd84ac0d93ed54a46e41eb891"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a0dc08e7fd84ac0d93ed54a46e41eb891">operator-&gt;</a> () const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ac03e5013f104eefa151281c29e6d95cd">pointer</a></td></tr>
<tr class="memdesc:a0dc08e7fd84ac0d93ed54a46e41eb891"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to member of pointer operator.  <br /></td></tr>
<tr class="separator:a0dc08e7fd84ac0d93ed54a46e41eb891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad4d8dae80a55c4ee7a46005eb5e17" id="r_a01ad4d8dae80a55c4ee7a46005eb5e17"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a01ad4d8dae80a55c4ee7a46005eb5e17">operator++</a> () -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;</td></tr>
<tr class="memdesc:a01ad4d8dae80a55c4ee7a46005eb5e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prefix increment operator.  <br /></td></tr>
<tr class="separator:a01ad4d8dae80a55c4ee7a46005eb5e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2ae523298d0da0435d56f65b493f3b" id="r_acf2ae523298d0da0435d56f65b493f3b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#acf2ae523298d0da0435d56f65b493f3b">operator++</a> (int) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:acf2ae523298d0da0435d56f65b493f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postfix increment operator.  <br /></td></tr>
<tr class="separator:acf2ae523298d0da0435d56f65b493f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9a82bd8288b224e29c2f6727628519" id="r_a9b9a82bd8288b224e29c2f6727628519"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a9b9a82bd8288b224e29c2f6727628519">operator+=</a> (int offset) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;</td></tr>
<tr class="memdesc:a9b9a82bd8288b224e29c2f6727628519"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition assignment operator.  <br /></td></tr>
<tr class="separator:a9b9a82bd8288b224e29c2f6727628519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5caad2aa382ae41781260a8068be7e7" id="r_ac5caad2aa382ae41781260a8068be7e7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ac5caad2aa382ae41781260a8068be7e7">operator+</a> (const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> other) const -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:ac5caad2aa382ae41781260a8068be7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator.  <br /></td></tr>
<tr class="separator:ac5caad2aa382ae41781260a8068be7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefe3f1145da7620615cd028ac5f426e" id="r_aeefe3f1145da7620615cd028ac5f426e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#aeefe3f1145da7620615cd028ac5f426e">operator--</a> () -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;</td></tr>
<tr class="memdesc:aeefe3f1145da7620615cd028ac5f426e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prefix decrement operator.  <br /></td></tr>
<tr class="separator:aeefe3f1145da7620615cd028ac5f426e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7acefdad5a1cfc84c6c24a4bbe92e0" id="r_a2b7acefdad5a1cfc84c6c24a4bbe92e0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a2b7acefdad5a1cfc84c6c24a4bbe92e0">operator--</a> (int) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:a2b7acefdad5a1cfc84c6c24a4bbe92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postfix decrement operator.  <br /></td></tr>
<tr class="separator:a2b7acefdad5a1cfc84c6c24a4bbe92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4dfd2fdef973770a011360eb032e2" id="r_a61e4dfd2fdef973770a011360eb032e2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a61e4dfd2fdef973770a011360eb032e2">operator-=</a> (int offset) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;</td></tr>
<tr class="memdesc:a61e4dfd2fdef973770a011360eb032e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subtraction assignment operator.  <br /></td></tr>
<tr class="separator:a61e4dfd2fdef973770a011360eb032e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c97bb9153984391be512ad1d4e3d99" id="r_ae2c97bb9153984391be512ad1d4e3d99"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#ae2c97bb9153984391be512ad1d4e3d99">operator-</a> (const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;other) const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a></td></tr>
<tr class="memdesc:ae2c97bb9153984391be512ad1d4e3d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subtraction operator (iterator overload).  <br /></td></tr>
<tr class="separator:ae2c97bb9153984391be512ad1d4e3d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1b734bee89866f029c671e8c46708f" id="r_a0b1b734bee89866f029c671e8c46708f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a0b1b734bee89866f029c671e8c46708f">operator-</a> (const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> other) const -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:a0b1b734bee89866f029c671e8c46708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subtraction operator (offset overload).  <br /></td></tr>
<tr class="separator:a0b1b734bee89866f029c671e8c46708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b619af888d658c34486216abe893706" id="r_a3b619af888d658c34486216abe893706"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a3b619af888d658c34486216abe893706">operator[]</a> (<a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> idx) const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a></td></tr>
<tr class="memdesc:a3b619af888d658c34486216abe893706"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index operator.  <br /></td></tr>
<tr class="separator:a3b619af888d658c34486216abe893706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897da9ff95468702b1aaffff843e7641" id="r_a897da9ff95468702b1aaffff843e7641"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a897da9ff95468702b1aaffff843e7641">operator&lt;=&gt;</a> (const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;other) const =default</td></tr>
<tr class="memdesc:a897da9ff95468702b1aaffff843e7641"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three-way comparison operator.  <br /></td></tr>
<tr class="separator:a897da9ff95468702b1aaffff843e7641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a892388274ec48701151e20cb9439e7d8" id="r_a892388274ec48701151e20cb9439e7d8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#a892388274ec48701151e20cb9439e7d8">operator+</a> (const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> value, const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;other) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:a892388274ec48701151e20cb9439e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The friend addition operator.  <br /></td></tr>
<tr class="separator:a892388274ec48701151e20cb9439e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb606a81df2a5f58da152ab2aaa0cf2f" id="r_acb606a81df2a5f58da152ab2aaa0cf2f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetargv_1_1Iterator.html#acb606a81df2a5f58da152ab2aaa0cf2f">operator-</a> (const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> value, const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> &amp;other) -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:acb606a81df2a5f58da152ab2aaa0cf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The friend subtraction operator (iterator and offset).  <br /></td></tr>
<tr class="separator:acb606a81df2a5f58da152ab2aaa0cf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
struct Getargv::Iterator&lt; T &gt;</div><p>A template that turns a pointer to a C style array into a C++ contiguous iterator. </p>
<p>The type parameter for this template is the <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> that the C array's pointer points to. The generated <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> struct is a contiguous iterator since C++ 20, and a random access iterator in C++ versions prior to C++ 20.</p>
<p>All operations are pointer math, which is a big reason why this is a template, so I only have to make sure one impl works. </p>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00022">22</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac0da64fb40e92a0a012c769183af72e2" name="ac0da64fb40e92a0a012c769183af72e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0da64fb40e92a0a012c769183af72e2">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::difference_type =  <a class="elRef" href="http://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type that represents the distance between two Iterators. The Iterators being compared must point to the same backing buffer, or you get UB. </p>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00042">42</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="ac726511006292065647099fdffa2ba26" name="ac726511006292065647099fdffa2ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac726511006292065647099fdffa2ba26">&#9670;&#160;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::element_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of the elements this iterator provides access to. The type of the iterator's elements/values is provided as a template parameter when this template is instantiated. </p>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00048">48</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a929ba25515da1946c3f655069420f3ea" name="a929ba25515da1946c3f655069420f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929ba25515da1946c3f655069420f3ea">&#9670;&#160;</a></span>iterator_concept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::iterator_concept =  <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/iterator_tags.html">std::contiguous_iterator_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A marker for the capabilities of this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>. This is the strongest type of iterator in C++ &gt;= 20, and we can satisfy the requirements, so users can use this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> with as many algorithms from <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm.html">std::algorithm</a> as possible. </p>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00029">29</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="ac03e5013f104eefa151281c29e6d95cd" name="ac03e5013f104eefa151281c29e6d95cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03e5013f104eefa151281c29e6d95cd">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::pointer =  <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a pointer to an element this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> provides access to. </p>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00061">61</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="ad7331be6d1d6accadcf214298c762ae7" name="ad7331be6d1d6accadcf214298c762ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7331be6d1d6accadcf214298c762ae7">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::reference =  <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a reference to an element this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> provides access to. </p>
<dl class="section warning"><dt>Warning</dt><dd>Trying to create a reference from an end <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> or an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> that has been incremented or decremented beyond the underlying array is UB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00068">68</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a2939378d534b9e2466d8063c382f73fa" name="a2939378d534b9e2466d8063c382f73fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2939378d534b9e2466d8063c382f73fa">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::value_type =  <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of the values this iterator provides access to. The type of the iterator's elements/values is provided as a template parameter when this template is instantiated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Clang++ doesn't seem to need this type specified, but everyone online says it's needed… </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00056">56</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ba70972deb99f5f4e5ac59815b8bae5" name="a2ba70972deb99f5f4e5ac59815b8bae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba70972deb99f5f4e5ac59815b8bae5">&#9670;&#160;</a></span>Iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::Iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGetargv_1_1Iterator.html#ac03e5013f104eefa151281c29e6d95cd">pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor that takes a pointer (C array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to an array of values/elements of <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a>, or 1 past the end of the array in the case of the end iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The iterator does not own the backing buffer, so the iterator is invalidated when the buffer is freed. There is no way of knowing based on the iterator itself if it has been invalidated.</dd>
<dd>
The type pointed to by the pointer passed to this constructor must match the type parameter used when instantiating the template. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00089">89</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aadc4d89dde9e9862d0198a374bd67ee8" name="aadc4d89dde9e9862d0198a374bd67ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc4d89dde9e9862d0198a374bd67ee8">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The indirection operator. </p>
<p>This operator returns the underlying <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> the iterator currently points to.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a> to the element of the array that the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> currently points to.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Trying to dereference an end iterator or an iterator that has been incremented to or beyond the end iterator, or decremented beyond the start iterator is UB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00103">103</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="ac5caad2aa382ae41781260a8068be7e7" name="ac5caad2aa382ae41781260a8068be7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5caad2aa382ae41781260a8068be7e7">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the number of elements the returned iterator should be advanced by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> advanced by the passed in number of positions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00166">166</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a01ad4d8dae80a55c4ee7a46005eb5e17" name="a01ad4d8dae80a55c4ee7a46005eb5e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad4d8dae80a55c4ee7a46005eb5e17">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The prefix increment operator. </p>
<p>This operator advances the iterator and returns itself.</p>
<dl class="section return"><dt>Returns</dt><dd>itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00127">127</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="acf2ae523298d0da0435d56f65b493f3b" name="acf2ae523298d0da0435d56f65b493f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2ae523298d0da0435d56f65b493f3b">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postfix increment operator. </p>
<p>This operator advances the iterator and returns an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> pointing to the old position.</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> pointing to the old position of this iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00139">139</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a9b9a82bd8288b224e29c2f6727628519" name="a9b9a82bd8288b224e29c2f6727628519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9a82bd8288b224e29c2f6727628519">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition assignment operator. </p>
<p>Advances the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> by the passed in number of positions and returns itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the number of elements to advance the iterator by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00154">154</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a0b1b734bee89866f029c671e8c46708f" name="a0b1b734bee89866f029c671e8c46708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1b734bee89866f029c671e8c46708f">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The subtraction operator (offset overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the number of positions to recede the returned <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> receded by the passed in number of positions.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The passed in iterator must point to the same backing buffer or this is UB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00241">241</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="ae2c97bb9153984391be512ad1d4e3d99" name="ae2c97bb9153984391be512ad1d4e3d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c97bb9153984391be512ad1d4e3d99">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The subtraction operator (iterator overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> to find the distance from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the passed <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> and this one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00228">228</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="aeefe3f1145da7620615cd028ac5f426e" name="aeefe3f1145da7620615cd028ac5f426e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefe3f1145da7620615cd028ac5f426e">&#9670;&#160;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The prefix decrement operator. </p>
<p>This operator recedes the iterator and returns itself.</p>
<dl class="section return"><dt>Returns</dt><dd>itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00190">190</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a2b7acefdad5a1cfc84c6c24a4bbe92e0" name="a2b7acefdad5a1cfc84c6c24a4bbe92e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7acefdad5a1cfc84c6c24a4bbe92e0">&#9670;&#160;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postfix decrement operator. </p>
<p>This operator recedes the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> and returns an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> pointing to the old position.</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> pointing to the old position of this iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00202">202</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a61e4dfd2fdef973770a011360eb032e2" name="a61e4dfd2fdef973770a011360eb032e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e4dfd2fdef973770a011360eb032e2">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The subtraction assignment operator. </p>
<p>Recedes the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> by the passed in number of positions, and returns itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the number of elements to recede the iterator by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00217">217</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a0dc08e7fd84ac0d93ed54a46e41eb891" name="a0dc08e7fd84ac0d93ed54a46e41eb891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc08e7fd84ac0d93ed54a46e41eb891">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ac03e5013f104eefa151281c29e6d95cd">pointer</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pointer to member of pointer operator. </p>
<p>This operator is only useful when the <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> of this iterator is a struct or class, and allows you to access members of the element pointed to by the iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying pointer of this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>. But more practically, the compiler then uses that pointer to provide access to a member of the pointed to struct.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Trying to use this operator on an end iterator or an iterator that has been incremented or decremented beyond the bounds of the underlying array is UB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00119">119</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="a897da9ff95468702b1aaffff843e7641" name="a897da9ff95468702b1aaffff843e7641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897da9ff95468702b1aaffff843e7641">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The three-way comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare this one to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/compare/strong_ordering.html">std::strong_ordering::less</a> if the other iterator is less than this one, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/compare/strong_ordering.html">std::strong_ordering::equal</a> if they are equal, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/compare/strong_ordering.html">std::strong_ordering::greater</a> if the other iterator is greater than this one. </dd></dl>

</div>
</div>
<a id="a3b619af888d658c34486216abe893706" name="a3b619af888d658c34486216abe893706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b619af888d658c34486216abe893706">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structGetargv_1_1Iterator.html">Getargv::Iterator</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index operator. </p>
<p>This operator returns the underlying <a class="el" href="structGetargv_1_1Iterator.html#ac726511006292065647099fdffa2ba26">element_type</a> the passed in number of positions removed from the position the iterator currently points to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the offset of the requested element from the current position of this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structGetargv_1_1Iterator.html#ad7331be6d1d6accadcf214298c762ae7">reference</a> to an element idx positions removed from this <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>'s current position.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>passing in an offset that would put the iterator beyond the bounds of the underlying array is UB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00272">272</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a892388274ec48701151e20cb9439e7d8" name="a892388274ec48701151e20cb9439e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892388274ec48701151e20cb9439e7d8">&#9670;&#160;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The friend addition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the number of elements the returned <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> should be advanced by.</td></tr>
    <tr><td class="paramname">other</td><td>the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> that provides the address to advance from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator which is the passed in <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> advanced by the passed in number of positions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00179">179</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<a id="acb606a81df2a5f58da152ab2aaa0cf2f" name="acb606a81df2a5f58da152ab2aaa0cf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb606a81df2a5f58da152ab2aaa0cf2f">&#9670;&#160;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html#ac0da64fb40e92a0a012c769183af72e2">difference_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structGetargv_1_1Iterator.html">Iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The friend subtraction operator (iterator and offset). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the number of positions to recede the returned <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a>.</td></tr>
    <tr><td class="paramname">other</td><td>the <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> that provides the address to recede from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator which is the passed in <a class="el" href="structGetargv_1_1Iterator.html" title="A template that turns a pointer to a C style array into a C++ contiguous iterator.">Iterator</a> receded by the passed in number of positions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iter_8hpp_source.html#l00252">252</a> of file <a class="el" href="iter_8hpp_source.html">iter.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="iter_8hpp_source.html">iter.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
